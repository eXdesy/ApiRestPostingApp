# Posting App Api Rest [SWAGGER](http://localhost:8080/swagger-ui/index.html)Es una red social desde cero, que permita a los usuarios crear perfiles únicos y conectarse con otros miembros. Cada usuario tendrá un conjunto de atributos distintivos que los identificarán en la plataforma:1. **Perfil de Usuario**:   - **Username**: Un nombre único que identifica al usuario en la red social.   - **Email**: Una dirección de correo electrónico única asociada al usuario para fines de autenticación y comunicación.   - **Contraseña**: Un código secreto elegido por el usuario para proteger su cuenta.   - **Descripción**: Una breve descripción opcional que el usuario puede proporcionar para presentarse a la comunidad.   - **Fecha de Creación**: La fecha en la que se creó la cuenta del usuario en la red social.2. **Publicaciones**:   - **Autor**: El usuario que crea y publica el contenido.   - **Texto**: El contenido de la publicación que puede incluir texto, imágenes, videos, etc.   - **Fecha de Creación**: La fecha en la que se creó la publicación.   - **Fecha de Edición**: La fecha en la que se editó por última vez la publicación (opcional).3. **Seguimiento de Usuarios**:   - Los usuarios pueden seguir a otros usuarios para mantenerse al tanto de sus actividades y contenido.   - Un usuario puede seguir a muchos otros usuarios.   - Un usuario puede ser seguido por muchos otros usuarios.La arquitectura de la base de datos necesaria para esta red social incluiría tablas separadas para los usuarios, publicaciones y relaciones de seguimiento. Además, se implementaría una lógica para garantizar que los usernames y correos electrónicos sean únicos en la base de datos y para registrar las relaciones de seguimiento entre los usuarios.## DEPENDENCIAS1. **spring-boot-starter-data-jpa**: Esta dependencia proporciona soporte para JPA (Java Persistence API) en aplicaciones Spring Boot, lo que facilita la interacción con bases de datos relacionales.2. **spring-boot-starter-web**: Proporciona un conjunto de dependencias para construir aplicaciones web utilizando Spring MVC y Tomcat embebido.3. **spring-boot-starter-security**: Proporciona integración con Spring Security para la autenticación y autorización en la aplicación.4. **lombok**: Esta es una biblioteca que ayuda a reducir la cantidad de código boilerplate en Java, generando automáticamente getters, setters, constructores, etc.5. **spring-boot-starter-test**: Contiene dependencias para realizar pruebas unitarias y de integración en aplicaciones Spring Boot.6. **spring-security-test**: Proporciona soporte para pruebas de seguridad en aplicaciones Spring Boot.7. **mysql-connector-java**: El conector JDBC para MySQL, que permite a la aplicación conectarse y comunicarse con una base de datos MySQL.8. **spring-boot-starter-thymeleaf**: Integra Thymeleaf, un motor de plantillas Java para la creación de vistas HTML en aplicaciones web.9. **jjwt-api**, **jjwt-impl**, **jjwt-jackson**: Estas dependencias son para trabajar con JSON Web Tokens (JWT), que son utilizados para la autenticación y autorización en aplicaciones web.10. **springdoc-openapi-starter-webmvc-ui**: Esta dependencia agrega soporte para la documentación de la API utilizando OpenAPI 3 (anteriormente conocido como Swagger), lo que facilita la creación de una documentación interactiva para la API REST.## BASE DE DATOSLas tablas de la base de datos representan entidades y relaciones clave para el funcionamiento de la red social. Aquí está la explicación de cada una:1. **rs_comment**:   - Esta tabla almacena los comentarios realizados por los usuarios en las publicaciones.   - `rs_comment_id`: Identificador único para cada comentario (clave primaria).   - `rs_comment_creation_date`: La fecha y hora en que se creó el comentario.   - `rs_comment_text`: El texto del comentario.   - `rs_comment_publication_id`: El identificador de la publicación a la que pertenece el comentario.   - `rs_comment_user_id`: El identificador del usuario que realizó el comentario.   - Las claves foráneas se refieren a las tablas `rs_publication` y `rs_user` respectivamente.2. **rs_follow**:   - Esta tabla registra las relaciones de seguimiento entre usuarios.   - `rs_follow_id`: Identificador único para cada relación de seguimiento (clave primaria).   - `rs_follow_followed`: El identificador del usuario seguido.   - `rs_follow_follower`: El identificador del usuario seguidor.   - Las claves foráneas se refieren a la tabla `rs_user`, indicando tanto al usuario seguido como al seguidor.3. **rs_publication**:   - Esta tabla almacena las publicaciones realizadas por los usuarios.   - `rs_publication_id`: Identificador único para cada publicación (clave primaria).   - `rs_publication_creation_date`: La fecha y hora en que se creó la publicación.   - `rs_publication_edition_date`: La fecha y hora de la última edición de la publicación.   - `rs_publication_image`: La URL de la imagen adjunta a la publicación (opcional).   - `rs_publication_text`: El texto de la publicación.   - `rs_publication_author`: El identificador del usuario que realizó la publicación.   - La clave foránea se refiere a la tabla `rs_user`, indicando al autor de la publicación.4. **rs_user**:   - Esta tabla almacena la información de los usuarios registrados en la red social.   - `rs_user_id`: Identificador único para cada usuario (clave primaria).   - `rs_user_creation_date`: La fecha en que se creó la cuenta del usuario.   - `rs_user_description`: Una breve descripción del usuario.   - `rs_user_email`: La dirección de correo electrónico única asociada al usuario (clave única).   - `rs_user_password`: La contraseña del usuario.   - `rs_user_name`: El nombre de usuario único (clave única).## SERVICIOSEstas clases de servicios están diseñadas para proporcionar la lógica empresarial y la funcionalidad necesaria para interactuar con la capa de persistencia y gestionar las operaciones relacionadas con los comentarios, las publicaciones y los usuarios en una red social. Aquí hay un resumen de cada clase de servicio:1. **CommentServiceImpl**:   - Proporciona servicios relacionados con los comentarios en la red social.   - Permite obtener una lista de comentarios asociados a una publicación específica.   - Permite agregar un comentario a una publicación.   - Convierte las entidades Comment a objetos CommentDTO para su manipulación y viceversa.2. **FollowServiceImpl**:   - Proporciona servicios relacionados con las relaciones de seguimiento en la red social.   - Permite establecer una relación de seguimiento entre un seguidor y un seguido.   - Permite eliminar una relación de seguimiento existente.   - Permite obtener una lista de usuarios seguidores de un usuario específico.   - Permite obtener una lista de usuarios seguidos por un usuario específico.   - Convierte las entidades User a objetos UserDTO para su manipulación.3. **PublicationServiceImpl**:   - Proporciona servicios relacionados con las publicaciones en la red social.   - Permite obtener todas las publicaciones en la red social o las publicaciones de un usuario específico.   - Permite crear, editar y eliminar publicaciones para un usuario específico.   - Permite obtener una publicación por su identificador único.   - Permite obtener las publicaciones de los usuarios seguidos por un usuario específico.   - Convierte las entidades Publication a objetos PublicationDTO para su manipulación.4. **UserServiceImpl**:   - Proporciona servicios relacionados con la gestión de usuarios en la red social.   - Permite registrar nuevos usuarios en el sistema.   - Permite iniciar sesión y cerrar sesión para usuarios existentes.   - Permite editar detalles de usuarios, como la descripción, el correo electrónico, etc.   - Permite obtener información sobre el usuario autenticado.   - Convierte las entidades User a objetos UserDTO para su manipulación.Cada clase de servicio está diseñada para cumplir con un conjunto específico de requisitos y proporciona métodos bien definidos para realizar operaciones relacionadas con comentarios, publicaciones, relaciones de seguimiento y usuarios en la red social.## ENDPOINTSLos endpoints se refieren a las diversas URL a las que se puede acceder para interactuar con la API de la red social:1. **Registrar un nuevo usuario**   - Método: POST   - URL: `/api/register`   - Descripción: Permite registrar un nuevo usuario en la red social proporcionando los datos del usuario.   ```public UserDTO registerUser(@RequestBody UserDTO userDTO) {    return userService.registerUser(userDTO.getUserName(), userDTO.getEmail(), userDTO.getPassword(), userDTO.getDescription());}```2. **Iniciar sesión de usuario**   - Método: POST   - URL: `/api/login`   - Descripción: Permite que un usuario inicie sesión en la red social proporcionando su nombre de usuario y contraseña.   ```public UserDTO loginUser(@RequestBody UserDTO userDTO) {    return userService.loginUser(userDTO.getUserName(), userDTO.getPassword());}```3. **Obtener todas las publicaciones**   - Método: GET   - URL: `/api/publication`   - Descripción: Recupera todas las publicaciones almacenadas en el sistema.   ```public ResponseEntity<List<PublicationDTO>> getAllPublications() {    List<PublicationDTO> allPublications = publicationService.getAllPublications();    return new ResponseEntity<>(allPublications, HttpStatus.OK);}```4. **Obtener todos los usuarios**   - Método: GET   - URL: `/api/user/all`   - Descripción: Obtiene la lista de todos los usuarios registrados en la red social.   ```public ResponseEntity<List<UserDTO>> getAllUsers() {    List<UserDTO> users = userService.getAllUsers();    return new ResponseEntity<>(users, HttpStatus.OK);}```5. **Obtener un usuario por su nombre de usuario**   - Método: GET   - URL: `/api/profile/{username}`   - Descripción: Recupera un usuario específico utilizando su nombre de usuario.   ```public ResponseEntity<UserDTO> getUserByUsername(@PathVariable String username) {    UserDTO user = userService.getUserByUsername(username);    if (user != null) {        return ResponseEntity.ok(user);    } else {        return ResponseEntity.status(HttpStatus.NOT_FOUND).build();    }}```6. **Obtener un usuario por su identificador único**   - Método: GET   - URL: `/api/user/{userId}`   - Descripción: Recupera un usuario utilizando su identificador único.   ```public ResponseEntity<UserDTO> getUserByUserId(@PathVariable(name = "userId") Long userId) {    UserDTO user = userService.getUserByUserId(userId);    if (user != null) {        return ResponseEntity.ok(user);    } else {        return ResponseEntity.status(HttpStatus.NOT_FOUND).build();    }}```7. **Obtener seguidores de un usuario por su identificador único**   - Método: GET   - URL: `/api/user/{userId}/followers`   - Descripción: Obtiene la lista de seguidores de un usuario específico.   ```public ResponseEntity<List<UserDTO>> getFollowersByUserId(@PathVariable(name = "userId") Long userId) {    List<UserDTO> followers = followService.getFollowersByUserId(userId);    if (followers != null) {        return ResponseEntity.ok(followers);    } else {        return ResponseEntity.status(HttpStatus.NOT_FOUND).build();    }}```8. **Obtener usuarios seguidos por un usuario por su identificador único**   - Método: GET   - URL: `/api/user/{userId}/following`   - Descripción: Recupera la lista de usuarios seguidos por un usuario específico.   ```public ResponseEntity<List<UserDTO>> getFollowingByUserId(@PathVariable(name = "userId") Long userId) {    List<UserDTO> following = followService.getFollowingByUserId(userId);    if (following != null) {        return ResponseEntity.ok(following);    } else {        return ResponseEntity.status(HttpStatus.NOT_FOUND).build();    }}```9. **Seguir a un usuario**   - Método: POST   - URL: `/api/user/{followerId}/follow/{followedId}`   - Descripción: Permite que un usuario siga a otro usuario.   ```public ResponseEntity<Void> followUser(@PathVariable(name = "followerId") Long followerId,                                       @PathVariable(name = "followedId") Long followedId) {    try {        followService.followUser(followerId, followedId);        return ResponseEntity.ok().build();    } catch (Exception e) {        log.error("Error during followUser: " + e.getMessage());        e.printStackTrace();        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();    }}```10. **Dejar de seguir a un usuario**    - Método: DELETE    - URL: `/api/user/{followerId}/unfollow/{followedId}`    - Descripción: Permite que un usuario deje de seguir a otro usuario.    ```public ResponseEntity<Void> unfollowUser(@PathVariable(name = "followerId") Long followerId,                                         @PathVariable(name = "followedId") Long followedId) {    try {        followService.unfollowUser(followerId, followedId);        return ResponseEntity.noContent().build();    } catch (Exception e) {        log.error("Error during unfollowUser: " + e.getMessage());        e.printStackTrace();        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();    }}```11. **Obtener publicaciones realizadas por un usuario**    - Método: GET    - URL: `/api/user/{userId}/publications`    - Descripción: Obtiene las publicaciones realizadas por un usuario específico.    ```public ResponseEntity<List<PublicationDTO>> getPublicationsByUserId(@PathVariable(name = "userId") Long userId) {    List<PublicationDTO> publications = publicationService.getPublicationsByUser(userId);    if (publications != null) {        return ResponseEntity.ok(publications);    } else {        return ResponseEntity.status(HttpStatus.NOT_FOUND).build();    }}```12. **Obtener el feed de un usuario**    - Método: GET    - URL: `/api/user/{userId}/feed`    - Descripción: Recupera el feed de un usuario, que incluye las publicaciones de los usuarios que sigue.    ```public ResponseEntity<List<PublicationDTO>> getFeedByUserId(@PathVariable(name = "userId") Long userId) {    List<PublicationDTO> feed = publicationService.getPublicationsByUsersFollowed(userId);    if (feed != null) {        return ResponseEntity.ok(feed);    } else {        return ResponseEntity.status(HttpStatus.NOT_FOUND).build();    }}```13. **Crear una nueva publicación para un usuario**    - Método: POST    - URL: `/api/user/{userId}/publication`    - Descripción: Permite que un usuario cree una nueva publicación en su perfil.    ```public ResponseEntity<PublicationDTO> createPublication(@PathVariable(name = "userId") Long userId,                                                       @io.swagger.v3.oas.annotations.parameters.RequestBody(                                                               description = "Publication details",                                                               content = @Content(schema = @Schema(implementation = PublicationDTO.class)),                                                               required = true                                                       )                                                       @RequestBody PublicationDTO publicationDTO) {    try {        System.out.println("Received request to create publication for user " + userId);        PublicationDTO createdPublication = publicationService.createPublication(userId, publicationDTO);        return ResponseEntity.status(HttpStatus.CREATED).body(createdPublication);    } catch (Exception e) {        log.error("Error during createPublication: " + e.getMessage());        e.printStackTrace();        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();    }}```14. **Editar una publicación existente**    - Método: PUT    - URL: `/api/user/{userId}/publication/{publicationId}`    - Descripción: Permite que un usuario edite una publicación que ha realizado.    ```public ResponseEntity<PublicationDTO> editPublication(@PathVariable(name = "userId") Long userId,                                                     @PathVariable(name = "publicationId") Long publicationId,                                                     @RequestBody PublicationDTO publicationDTO) {    try {        PublicationDTO editedPublication = publicationService.editPublication(userId, publicationId, publicationDTO);        return ResponseEntity.ok(editedPublication);    } catch (Exception e) {        log.error("Error during editPublication: " + e.getMessage());        e.printStackTrace();        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();    }}```15. **Eliminar una publicación existente**    - Método: DELETE    - URL: `/api/user/{userId}/publication/{publicationId}`    - Descripción: Permite que un usuario elimine una de sus publicaciones.    ```public ResponseEntity<Void> deletePublication(@PathVariable(name = "userId") Long userId,                                              @PathVariable(name = "publicationId") Long publicationId) {    try {        publicationService.deletePublication(userId, publicationId);        return ResponseEntity.noContent().build();    } catch (Exception e) {        log.error("Error during deletePublication: " + e.getMessage());        e.printStackTrace();        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();    }}```16. **Obtener una publicación por su identificador único**    - Método: GET    - URL: `/api/publication/{publicationId}`    - Descripción: Recupera una publicación específica utilizando su identificador único.    ```public ResponseEntity<PublicationDTO> getPublicationById(@PathVariable("publicationId") Long publicationId) {    try {        PublicationDTO publication = publicationService.getPublicationByPublicationId(publicationId);        if (publication != null) {            return ResponseEntity.ok(publication);        } else {            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();        }    } catch (Exception e) {        log.error("Error during getPublicationById: " + e.getMessage());        e.printStackTrace();        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();    }}```17. **Editar detalles de un usuario**    - Método: PUT    - URL: `/{userId}/edit/details`    - Descripción: Permite editar los detalles de un usuario, como su descripción y dirección de correo electrónico.    ```public ResponseEntity<Map<String, String>> editUserDetails(        @PathVariable(name = "userId") Long userId,        @Parameter(description = "New user details", content = @Content(schema = @Schema(implementation = String.class)))        @RequestBody Map<String, String> userDetails) {    System.out.println("Received Request - User ID: " + userId + ", New Details: " + userDetails);    try {        Map<String, String> updatedDetails = userService.editUserDetails(                userId,                userDetails.get("newDescription"),                userDetails.get("newEmail"));        return ResponseEntity.ok(updatedDetails);    } catch (DataIntegrityViolationException e) {        log.error("Error during editUserDetails: " + e.getMessage());        e.printStackTrace();        return ResponseEntity.status(HttpStatus.CONFLICT).build();    } catch (Exception e) {        log.error("Error during editUserDetails: " + e.getMessage());        e.printStackTrace();        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();    }}```18. **Obtener todos los comentarios asociados a una publicación**    - Método: GET    - URL: `/api/publication/{publicationId}/comments`    - Descripción: Obtiene todos los comentarios asociados a una publicación específica.    ```public ResponseEntity<List<CommentDTO>> getCommentsByPublicationId(@PathVariable(name = "publicationId") Long publicationId) {    try {        List<CommentDTO> comments = commentService.getCommentsByPublicationId(publicationId);        return ResponseEntity.ok(comments);    } catch (Exception e) {        log.error("Error getting comments for publication ID " + publicationId + ": " + e.getMessage());        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();    }}```19. **Agregar un comentario a una publicación**    - Método: POST    - URL: `/api/publication/{publicationId}/comments/user/{userId}`    - Descripción: Permite que un usuario agregue un comentario a una publicación específica.```public ResponseEntity<CommentDTO> addComment(@PathVariable(name = "publicationId") Long publicationId,                                             @PathVariable(name = "userId") Long userId,                                             @RequestBody CommentDTO commentDTO) {    try {        CommentDTO addedComment = commentService.addComment(userId, publicationId, commentDTO);        return ResponseEntity.ok(addedComment);    } catch (Exception e) {        log.error("Error adding comment to publication ID " + publicationId + ": " + e.getMessage());        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();    }}```